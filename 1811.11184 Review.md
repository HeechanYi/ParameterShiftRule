Evaluating Anlytic Gradients on Quantum Hardware
=======

***Paper***<br>
[*Evaluating Anlytic Gradients on Quantum Hardware*](https://arxiv.org/abs/1811.11184)

### Introduction

For Gradient-Descent-based optimization stratagies $\Leftarrow$ **Gradients of qunatum computations**

Computing on quantum hardware<br>
The derivative of a qunatum expectation with respect to a parameter $\mu$ used in gate $\mathcal{G}$ involves *"Derivative of the gate"*, $\partial_\mu\mathcal{G}$

<U>Rules to compute the partial derivatives of quantum expectation values with respect to gate parameters on quantum hardware</U><br>
&nbsp; &nbsp; &nbsp; &nbsp; If the derivative $\partial_\mu\mathcal{G}$ and the observable can be decomposed<br>
&nbsp; &nbsp; &nbsp; &nbsp; $\Rightarrow$ We can evaluate teh derivative of an expectation by measuring an overlap of two quantum states

1. Parameter Shift Rule : holding for any gate of the form $\mathcal{G} = e^{-i\mu G}$ (Hermitain generator $G$ has at most two distinct eigenvalues)
2. Any gate $\leftarrow$ linear combination of unitaries<br>
   Requires adding a single ancilla qubit while running the circuit
3. Parameter Shift Rules for Gaussian Gates

<div align="center">
The Parameter Shift Rule in the larger context of hybrid optimization<br>
<img src = "Figures/[1811.11184]Figure 1.png"  width=100% title="Figure 1" >
<div align="left"><br>

### Section 2. Computing Quantum Gradients

Quantum algoritm consits of gate sequence $U(\vec{\theta})$ followed by the meaurement $\hat{B}$ $\longrightarrow$ $\textit{varational quantum circuit}$

VQC $\Rightarrow$ $f : \mathbb{R}^m \rightarrow \mathbb{R}^n$ where $f(\vec{\theta}) := \braket{\hat{B}} = \braket{0|U^{\dagger}(\theta)\hat{B}U(\theta)|0}$

Its physical implementation on a qunatum device runs the quantum algorithm an measurement smaples to get an *estimate* of $f(\vec{\theta})$

<U>Partial Derivative</U> $\partial_\mu f(\vec{\theta})$

The partial derivatives w.r.t. all gate parameters form the gradient
$$\nabla f(\vec{\theta}) = \left[ {\partial f \over \partial \mu}\right]_{\mu \in \vec{\theta}}$$
The differentian rules consider the **Expectation value**<br>
VQC(*'anlytic'* definition & *'stochastic'* implementation)<br>
$\rightarrowtail$ *Evolution* of these rulse with finite runs on noisy hardware returns ***estimates of the gradients***

Main approach to evaluate the gradients of a numerical computation

>1. $\textit{Numerical Differentiation}$<br>
>   $\nabla g(x) \approx {1\over \triangle x}[g(x+{\triangle x / 2})-g(x->{\triangle x / 2})]$<br>
>2. $\textit{Automatic Differentiation}$<br>
>   The gradient is efficiently computed through the accumulation of intermediate derivaitves correspondig to different subfunctions used to build g, following the chain rule [[Autograd: Effortless gradients in numpy](https://indico.ijclab.in2p3.fr/event/2914/contributions/6483/subcontributions/180/attachments/6060/7185/automl-short.pdf)]
>3. $\textit{Symbolic Differentiation}$<br>
>   Using manual calculations of a symbolic computer algebra package, the function, $\nabla g$ is constructer and evaluated

In Quantum Variational literature $\rightarrow$ numerical  differentiation $\parallel$ high error of near-term quantum device<br>
In Machine Learning $\rightarrow$ automatic differentiation $\parallel$ storing and reusing problem of the intermediate derivative inside quantum computation<br>

$\Rightarrow$ Deriving an equation for $\partial_\mu f(\vec{\theta}), \mu \in \vec{\theta}$, whose constituent parts can be evaluated on a quantum computer and subsequently combined on a classical coprocessor

> **Property of $\partial_\mu f(\vec{\theta})$**<br>
> - It follows similar rules for a range of different circuits
> - Can be done on a circuit architecture($\approx$ evaluating $f(\vec{\theta})$)
> - Requires the evaluation of only two expectation values

Summary
<div align="center">
<img src = "Figures/[1811.11184]Table 1.png"  width=100% title="Table 1" >
<div align="left">

### Section 3. Gradients of Discrete-Variable Circuits


